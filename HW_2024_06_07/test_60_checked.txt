1 - 2 ✅
2 - 1 ✅
3 - 3 ✅
4 - 2 ✅
5 - 2 ✅
6 - 3 ✅
7 - 1 ✅
8 - 3 ✅
9 - 1 ✅
10 - 2 ✅
11 - 4 ✅
12 - 4 ✅
13 - 2 ✅
14 - 3 ✅
15 - 1 ✅
16 - 1 ✅
17 - 4 ✅
18 - 2 ✅
19 - 3 ✅
20 - 1 ✅
21 - ❌, правильный ответ: 4, ваш ответ: 1
22 - 1 ✅
23 - 3 ✅
24 - 4 ✅
25 - 1 ✅
26 - 3 ✅
27 - 1 ✅
28 - 2 ✅
29 - 4 ✅
30 - 3 ✅
31 - 2 ✅
32 - 3 ✅
33 - 4 ✅
34 - 4 ✅
35 - 2 ✅
36 - ❌, правильный ответ: 2, ваш ответ: 3
37 - 2 ✅
38 - ❌, правильный ответ: 3, ваш ответ: 2
39 - 4 ✅
40 - 3 ✅
41 - 1 ✅
42 - 2 ✅
43 - ❌, правильный ответ: 3, ваш ответ: 2
44 - 1 ✅
45 - 4 ✅
46 - 2 ✅
47 - 2 ✅
48 - 3 ✅
49 - 4 ✅
50 - 1 ✅
51 - 4 ✅
52 - ❌, правильный ответ: 4, ваш ответ: 1
53 - 1 ✅
54 - ❌, правильный ответ: 3, ваш ответ: 4
55 - 4 ✅
56 - 4 ✅
57 - 2 ✅
58 - 4 ✅
59 - 1 ✅
60 - 3 ✅

##############################
Правильных ответов: 54
Не правильных ответов: 6 [21, 36, 38, 43, 52, 54]
Пропущено ответов: 0 

За каждый правильный ответ вы получаете 0.2 балла.
При дробной оценке округление в большую сторону.
Ваш балл: 11
##############################

Вопрос 21: 
    Если вы попытаетесь получить доступ к атрибуту экземпляра, который не был определен, возникает ошибка AttributeError.
    Это означает, что атрибут не существует в экземпляре класса.
    Пример:
    ```python
    class MyClass:
        pass

    obj = MyClass()
    print(obj.non_existent_attribute)  # AttributeError: 'MyClass' object has no attribute 'non_existent_attribute'
    ```
    
Вопрос 36: 
    Метод __mul__ используется для определения поведения экземпляра класса при операции умножения.
    Он должен возвращать результат умножения объекта на другой объект.
    Пример:
    ```python
    class MyClass:
        def __init__(self, value):
            self.value = value

        def __mul__(self, other):
            if isinstance(other, MyClass):
                return MyClass(self.value * other.value)
            return NotImplemented
    ```
    
Вопрос 38: 
    Класс bool не наследуется напрямую от класса object.
    Он наследуется от класса int, который, в свою очередь, наследуется от класса object.
    Пример:
    ```python
    class bool(int):
        pass
    ```
    
Вопрос 43: 
    Порядок разрешения методов (MRO) в Python используется для определения, какой метод будет вызван, если он определен в нескольких классах в иерархии наследования.
    Это позвочает избежать конфликтов имен и обеспечить правильное выполнение методов.
    Пример:
    ```python
    class A:
        pass

    class B(A):
        pass

    class C(B):
        pass

    print(C.__mro__)  # (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
    ```
    
Вопрос 52: 
    Если подкласс не реализует все абстрактные методы абстрактного базового класса, произойдет ошибка в момент вызова класса.
    Это означает, что подкласс не может быть создан, пока он не реализует все абстрактные методы.
    Пример:
    ```python
    from abc import ABC, abstractmethod

    class MyAbstractClass(ABC):
        @abstractmethod
        def my_abstract_method(self):
            pass

    class MyConcreteClass(MyAbstractClass):
        pass

    obj = MyConcreteClass()  # TypeError: Can't instantiate abstract class MyConcreteClass with abstract methods my_abstract_method
    ```
    
Вопрос 54: 
    В шаблоне Singleton обычно создаётся экземпляр класса по требованию или лениво, когда это впервые необходимо.
    Это позволяет создать единственный экземпляр класса и использовать его повторно.
    Пример:
    ```python
    class Singleton:
        _instance = None

        def __new__(cls, *args, **kwargs):
            if not cls._instance:
                cls._instance = super().__new__(cls)
            return cls._instance
    ```
    
